{"version":3,"sources":["../dicom-cornerstone/ConnectedCornerstoneViewport.js","../dicom-cornerstone/OHIFCornerstoneViewport.js"],"names":["OHIF","redux","actions","setViewportActive","setViewportSpecificData","measurements","MeasurementHandlers","onAdded","onRemoved","onModified","MEASUREMENT_ACTION_MAP","added","removed","modified","throttle","event","ConnectedCornerstoneViewport","connect","state","ownProps","dataFromStore","extensions","cornerstone","viewportIndex","isActive","viewports","activeViewportIndex","viewportSpecificData","isPlaying","frameRate","cine","cineFrameRate","isStackPrefetchEnabled","dispatch","data","onElementEnabled","enabledElement","detail","element","setEnabledElement","plugin","onMeasurementsChanged","action","CornerstoneViewport","StackManager","utils","OHIFCornerstoneViewport","viewportData","getViewportData","studies","StudyInstanceUID","displaySetInstanceUID","SOPInstanceUID","frameIndex","a","stack","getCornerstoneStack","this","props","displaySet","sopClassUIDs","length","console","warn","then","setState","setStateFromProps","prevProps","prevDisplaySet","childrenWithProps","imageIds","currentImageIdIndex","children","map","child","index","React","cloneElement","key","imageIdIndex","onNewImage","sopInstanceUid","onNewImageDebounceTime","customProps","log","clearStacks","Error","study","find","displaySets","set","storedStack","findOrCreateStack","Object","assign","findIndex","imageId","metaData","get","Component","defaultProps","id"],"mappings":"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","file":"static/js/11.576b6262.chunk.js","sourcesContent":["import CornerstoneViewport from 'react-cornerstone-viewport';\nimport OHIF from '@ohif/core';\nimport { connect } from 'react-redux';\nimport throttle from 'lodash.throttle';\nimport { setEnabledElement } from './state';\n\nconst { setViewportActive, setViewportSpecificData } = OHIF.redux.actions;\nconst {\n  onAdded,\n  onRemoved,\n  onModified,\n} = OHIF.measurements.MeasurementHandlers;\n\n// TODO: Transition to enums for the action names so that we can ensure they stay up to date\n// everywhere they're used.\nconst MEASUREMENT_ACTION_MAP = {\n  added: onAdded,\n  removed: onRemoved,\n  modified: throttle(event => {\n    return onModified(event);\n  }, 300),\n};\n\nconst mapStateToProps = (state, ownProps) => {\n  let dataFromStore;\n\n  // TODO: This may not be updated anymore :thinking:\n  if (state.extensions && state.extensions.cornerstone) {\n    dataFromStore = state.extensions.cornerstone;\n  }\n\n  // If this is the active viewport, enable prefetching.\n  const { viewportIndex } = ownProps; //.viewportData;\n  const isActive = viewportIndex === state.viewports.activeViewportIndex;\n  const viewportSpecificData =\n    state.viewports.viewportSpecificData[viewportIndex] || {};\n\n  // CINE\n  let isPlaying = false;\n  let frameRate = 24;\n\n  if (viewportSpecificData && viewportSpecificData.cine) {\n    const cine = viewportSpecificData.cine;\n\n    isPlaying = cine.isPlaying === true;\n    frameRate = cine.cineFrameRate || frameRate;\n  }\n\n  return {\n    // layout: state.viewports.layout,\n    isActive,\n    // TODO: Need a cleaner and more versatile way.\n    // Currently justing using escape hatch + commands\n    // activeTool: activeButton && activeButton.command,\n    ...dataFromStore,\n    isStackPrefetchEnabled: isActive,\n    isPlaying,\n    frameRate,\n    //stack: viewportSpecificData.stack,\n    // viewport: viewportSpecificData.viewport,\n  };\n};\n\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  const { viewportIndex } = ownProps;\n\n  return {\n    setViewportActive: () => {\n      dispatch(setViewportActive(viewportIndex));\n    },\n\n    setViewportSpecificData: data => {\n      dispatch(setViewportSpecificData(viewportIndex, data));\n    },\n\n    /**\n     * Our component \"enables\" the underlying dom element on \"componentDidMount\"\n     * It listens for that event, and then emits the enabledElement. We can grab\n     * a reference to it here, to make playing with cornerstone's native methods\n     * easier.\n     */\n    onElementEnabled: event => {\n      const enabledElement = event.detail.element;\n      setEnabledElement(viewportIndex, enabledElement);\n      dispatch(\n        setViewportSpecificData(viewportIndex, {\n          // TODO: Hack to make sure our plugin info is available from the outset\n          plugin: 'cornerstone',\n        })\n      );\n    },\n\n    onMeasurementsChanged: (event, action) => {\n      return MEASUREMENT_ACTION_MAP[action](event);\n    },\n  };\n};\n\nconst ConnectedCornerstoneViewport = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(CornerstoneViewport);\n\nexport default ConnectedCornerstoneViewport;\n","import React, { Component } from 'react';\n\nimport ConnectedCornerstoneViewport from './ConnectedCornerstoneViewport';\nimport OHIF from '@ohif/core';\nimport PropTypes from 'prop-types';\nimport cornerstone from 'cornerstone-core';\n\nconst { StackManager } = OHIF.utils;\n\nclass OHIFCornerstoneViewport extends Component {\n  state = {\n    viewportData: null,\n  };\n\n  static defaultProps = {\n    customProps: {},\n  };\n\n  static propTypes = {\n    studies: PropTypes.object,\n    displaySet: PropTypes.object,\n    viewportIndex: PropTypes.number,\n    children: PropTypes.node,\n    customProps: PropTypes.object,\n  };\n\n  static id = 'OHIFCornerstoneViewport';\n\n  static init() {\n    console.log('OHIFCornerstoneViewport init()');\n  }\n\n  static destroy() {\n    console.log('OHIFCornerstoneViewport destroy()');\n    StackManager.clearStacks();\n  }\n\n  /**\n   * Obtain the CornerstoneTools Stack for the specified display set.\n   *\n   * @param {Object[]} studies\n   * @param {String} StudyInstanceUID\n   * @param {String} displaySetInstanceUID\n   * @param {String} [SOPInstanceUID]\n   * @param {Number} [frameIndex=1]\n   * @return {Object} CornerstoneTools Stack\n   */\n  static getCornerstoneStack(\n    studies,\n    StudyInstanceUID,\n    displaySetInstanceUID,\n    SOPInstanceUID,\n    frameIndex = 0\n  ) {\n    if (!studies || !studies.length) {\n      throw new Error('Studies not provided.');\n    }\n\n    if (!StudyInstanceUID) {\n      throw new Error('StudyInstanceUID not provided.');\n    }\n\n    if (!displaySetInstanceUID) {\n      throw new Error('StudyInstanceUID not provided.');\n    }\n\n    // Create shortcut to displaySet\n    const study = studies.find(\n      study => study.StudyInstanceUID === StudyInstanceUID\n    );\n\n    if (!study) {\n      throw new Error('Study not found.');\n    }\n\n    const displaySet = study.displaySets.find(set => {\n      return set.displaySetInstanceUID === displaySetInstanceUID;\n    });\n\n    if (!displaySet) {\n      throw new Error('Display Set not found.');\n    }\n\n    // Get stack from Stack Manager\n    const storedStack = StackManager.findOrCreateStack(study, displaySet);\n\n    // Clone the stack here so we don't mutate it\n    const stack = Object.assign({}, storedStack);\n    stack.currentImageIdIndex = frameIndex;\n\n    if (SOPInstanceUID) {\n      const index = stack.imageIds.findIndex(imageId => {\n        const imageIdSOPInstanceUID = cornerstone.metaData.get(\n          'SOPInstanceUID',\n          imageId\n        );\n\n        return imageIdSOPInstanceUID === SOPInstanceUID;\n      });\n\n      if (index > -1) {\n        stack.currentImageIdIndex = index;\n      } else {\n        console.warn(\n          'SOPInstanceUID provided was not found in specified DisplaySet'\n        );\n      }\n    }\n\n    return stack;\n  }\n\n  getViewportData = async (\n    studies,\n    StudyInstanceUID,\n    displaySetInstanceUID,\n    SOPInstanceUID,\n    frameIndex\n  ) => {\n    let viewportData;\n\n    const stack = OHIFCornerstoneViewport.getCornerstoneStack(\n      studies,\n      StudyInstanceUID,\n      displaySetInstanceUID,\n      SOPInstanceUID,\n      frameIndex\n    );\n\n    viewportData = {\n      StudyInstanceUID,\n      displaySetInstanceUID,\n      stack,\n    };\n\n    return viewportData;\n  };\n\n  setStateFromProps() {\n    const { studies, displaySet } = this.props.viewportData;\n    const {\n      StudyInstanceUID,\n      displaySetInstanceUID,\n      sopClassUIDs,\n      SOPInstanceUID,\n      frameIndex,\n    } = displaySet;\n\n    if (!StudyInstanceUID || !displaySetInstanceUID) {\n      return;\n    }\n\n    if (sopClassUIDs && sopClassUIDs.length > 1) {\n      console.warn(\n        'More than one SOPClassUID in the same series is not yet supported.'\n      );\n    }\n\n    this.getViewportData(\n      studies,\n      StudyInstanceUID,\n      displaySetInstanceUID,\n      SOPInstanceUID,\n      frameIndex\n    ).then(viewportData => {\n      this.setState({\n        viewportData,\n      });\n    });\n  }\n\n  componentDidMount() {\n    this.setStateFromProps();\n  }\n\n  componentDidUpdate(prevProps) {\n    const { displaySet } = this.props.viewportData;\n    const prevDisplaySet = prevProps.viewportData.displaySet;\n\n    if (\n      displaySet.displaySetInstanceUID !==\n      prevDisplaySet.displaySetInstanceUID ||\n      displaySet.SOPInstanceUID !== prevDisplaySet.SOPInstanceUID ||\n      displaySet.frameIndex !== prevDisplaySet.frameIndex\n    ) {\n      this.setStateFromProps();\n    }\n  }\n\n  render() {\n    let childrenWithProps = null;\n\n    if (!this.state.viewportData) {\n      return null;\n    }\n    const { viewportIndex } = this.props;\n    const {\n      imageIds,\n      currentImageIdIndex,\n      // If this comes from the instance, would be a better default\n      // `FrameTime` in the instance\n      // frameRate = 0,\n    } = this.state.viewportData.stack;\n\n    // TODO: Does it make more sense to use Context?\n    if (this.props.children && this.props.children.length) {\n      childrenWithProps = this.props.children.map((child, index) => {\n        return (\n          child &&\n          React.cloneElement(child, {\n            viewportIndex: this.props.viewportIndex,\n            key: index,\n          })\n        );\n      });\n    }\n\n    const newImageHandler = ({ currentImageIdIndex, sopInstanceUid }) => {\n      const { displaySet } = this.props.viewportData;\n      const { StudyInstanceUID } = displaySet;\n\n      if (currentImageIdIndex > 0) {\n        this.props.onNewImage({\n          StudyInstanceUID,\n          SOPInstanceUID: sopInstanceUid,\n          frameIndex: currentImageIdIndex,\n          activeViewportIndex: viewportIndex,\n        });\n      }\n    };\n\n    return (\n      <>\n        <ConnectedCornerstoneViewport\n          viewportIndex={viewportIndex}\n          imageIds={imageIds}\n          imageIdIndex={currentImageIdIndex}\n          onNewImage={newImageHandler}\n          onNewImageDebounceTime={700}\n          // ~~ Connected (From REDUX)\n          // frameRate={frameRate}\n          // isPlaying={false}\n          // isStackPrefetchEnabled={true}\n          // onElementEnabled={() => {}}\n          // setViewportActive{() => {}}\n          {...this.props.customProps}\n        />\n        {childrenWithProps}\n      </>\n    );\n  }\n}\n\nexport default OHIFCornerstoneViewport;\n"],"sourceRoot":""}